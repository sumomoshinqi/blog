<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c | sumomoshinqi]]></title>
  <link href="http://sumomoshinqi.github.io/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://sumomoshinqi.github.io/"/>
  <updated>2015-03-23T16:40:39+08:00</updated>
  <id>http://sumomoshinqi.github.io/</id>
  <author>
    <name><![CDATA[sumomoshinqi]]></name>
    <email><![CDATA[edam.lqq@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[CSAPP] Data Lab]]></title>
    <link href="http://sumomoshinqi.github.io/blog/2015/03/23/csapp-data-lab/"/>
    <updated>2015-03-23T16:34:31+08:00</updated>
    <id>http://sumomoshinqi.github.io/blog/2015/03/23/csapp-data-lab</id>
    <content type="html"><![CDATA[<p>Data Lab: Manipulating Bits</p>

<!--more-->


<pre><code class="C bit.c">/* 
 * bitOr - x|y using only ~ and &amp; 
 *   Example: bitOr(6, 5) = 7
 *   Legal ops: ~ &amp;
 *   Max ops: 8
 *   Rating: 1
 */
int bitOr(int x, int y) {
    return ~((~x)&amp;(~y));
}
/* 
 * anyOddBit - return 1 if any odd-numbered bit in word set to 1
 *   Examples anyOddBit(0x5) = 0, anyOddBit(0x7) = 1
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 2
 */
int anyOddBit(int x) {
    return (x&amp;1) | ((x&amp;4)&gt;&gt;2) | ((x&amp;16)&gt;&gt;4) | ((x&amp;64)&gt;&gt;6) | ((x&amp;256)&gt;&gt;8) | ((x&amp;1024)&gt;&gt;10) | ((x&amp;1073741824)&gt;&gt;30);
}
/* 
 * copyLSB - set all bits of result to least significant bit of x
 *   Example: copyLSB(5) = 0xFFFFFFFF, copyLSB(6) = 0x00000000
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 5
 *   Rating: 2
 */
int copyLSB(int x) {
  return ((x &lt;&lt; 31) &gt;&gt; 31);
}
/* 
 * bitMask - Generate a mask consisting of all 1's 
 *   lowbit and highbit
 *   Examples: bitMask(5,3) = 0x38
 *   Assume 0 &lt;= lowbit &lt;= 31, and 0 &lt;= highbit &lt;= 31
 *   If lowbit &gt; highbit, then mask should be all 0's
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 16
 *   Rating: 3
 */
int bitMask(int highbit, int lowbit) {
    int mask1 = ~0 &lt;&lt; highbit;
    int mask2 = ~(~0 &lt;&lt; lowbit);
    int mask3 = ~(1 &lt;&lt; highbit);
    mask1 = mask1 &amp; mask3;

    return ~(mask1 | mask2);
}
/* 
 * reverseBytes - reverse the bytes of x
 *   Example: reverseBytes(0x01020304) = 0x04030201
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 25
 *   Rating: 3
 */
int reverseBytes(int x) {


    int newbyte0 = (x &gt;&gt; 24) &amp; 0xff;
    int newbyte1 = (x &gt;&gt; 8) &amp; 0xff00;
    int newbyte2 = (x &lt;&lt; 8) &amp; (0xff&lt;&lt;8);
    int newbyte3 = x &lt;&lt; 24;

    return newbyte0 | newbyte1 | newbyte2 | newbyte3;
}
/* 
 * conditional - same as x ? y : z 
 *   Example: conditional(2,4,5) = 4
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 16
 *   Rating: 3
 */
int conditional(int x, int y, int z) {
    int num;
    num = -1;
    (((!x)+num)&amp;y) + ((~((!x)+num))&amp;z); 
}
/* 
 * bang - Compute !x without using !
 *   Examples: bang(3) = 0, bang(0) = 1
 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 4 
 */
int bang(int x) {    
    x = ( x &gt;&gt; 16 ) | x;
    x = ( x &gt;&gt; 8 ) | x;
    x = ( x &gt;&gt; 4 ) | x;
    x = ( x &gt;&gt; 2 ) | x;
    x = ( x &gt;&gt; 1) | x;

    return ~x &amp; 1;
}
/*
 * isTmax - returns 1 if x is the maximum, two's complement number,
 *     and 0 otherwise 
 *   Legal ops: ! ~ &amp; ^ | +
 *   Max ops: 10
 *   Rating: 1
 */
int isTmax(int x) {
    int m;
    m = (1 &lt;&lt; 31) + 1;

    return !(x ^ m);
}
/* 
 * fitsBits - return 1 if x can be represented as an 
 *  n-bit, two's complement integer.
 *   1 &lt;= n &lt;= 32
 *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 15
 *   Rating: 2
 */
int fitsBits(int x, int n) {
    int mask = x &gt;&gt; 31;

    return !(((~x &amp; mask) + (x &amp; ~mask)) &gt;&gt; (n + ~0));
}
/* 
 * isNotEqual - return 0 if x == y, and 1 otherwise 
 *   Examples: isNotEqual(5,5) = 0, isNotEqual(4,5) = 1
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 6
 *   Rating: 2
 */
int isNotEqual(int x, int y) {
  return (!!(x ^ y));
}
/* 
 * logicalShift - shift x to the right by n, using a logical shift
 *   Can assume that 0 &lt;= n &lt;= 31
 *   Examples: logicalShift(0x87654321,4) = 0x08765432
 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 20
 *   Rating: 3 
 */
int logicalShift(int x, int n) {
    int one = 0x1 &lt;&lt; 31, two, three;
    x = x &gt;&gt; n;
    two = one &gt;&gt; n;
    three = ~(two &lt;&lt; 1);

    return x &amp; three;
}
/* 
 * rotateLeft - Rotate x to the left by n
 *   Can assume that 0 &lt;= n &lt;= 31
 *   Examples: rotateLeft(0x87654321,4) = 0x76543218
 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 25
 *   Rating: 3 
 */
int rotateLeft(int x, int n) {
    return (x &lt;&lt; n) | (x &gt;&gt; (32 - n)) &amp; ~(-1 &lt;&lt; n);
}
/* 
 * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')
 *   Example: isAsciiDigit(0x35) = 1.
 *            isAsciiDigit(0x3a) = 0.
 *            isAsciiDigit(0x05) = 0.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 15
 *   Rating: 3
 */
int isAsciiDigit(int x) {
  return (!(x&lt;&lt;6))&amp;((x &lt;&lt; 5)) &amp; (x &lt;&lt; 4) &amp; (~(x &lt;&lt; 3) | (~(x &lt;&lt; 2) &amp; ~(x &lt;&lt; 1)));
}
/* 
 * absVal - absolute value of x
 *   Example: absVal(-1) = 1.
 *   You may assume -TMax &lt;= x &lt;= TMax
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 10
 *   Rating: 4
 */
int absVal(int x) {
    int z; 
    z = x&gt;&gt;31;
    z = z&amp;1;
    z = ~z;
    z = z+1;
    z = x^z;
    int y; 
    y= x&gt;&gt;31;
    y = y&amp;1;
    z = z+y;

    return z;
}
/* 
 * isNonZero - Check whether x is nonzero using
 *              the legal operators except !
 *   Examples: isNonZero(3) = 1, isNonZero(0) = 0
 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 10
 *   Rating: 4 
 */
int isNonZero(int x) {
    int n = ~x + 1;

    return ((n &gt;&gt; 31) | (x &gt;&gt; 31)) &amp; 1;
}
/* 
 * bitAnd - x&amp;y using only ~ and | 
 *   Example: bitAnd(6, 5) = 4
 *   Legal ops: ~ |
 *   Max ops: 8
 *   Rating: 1
 */
int bitAnd(int x, int y) {
  return ~(~x | ~y);  //Using De Morgan's law
}
/* 
 * getByte - Extract byte n from word x
 *   Bytes numbered from 0 (LSB) to 3 (MSB)
 *   Examples: getByte(0x12345678,1) = 0x56
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 6
 *   Rating: 2
 */
int getByte(int x, int n) {
  /*
   *First we rightshift x (fine if you like to leftshift :D)
   *Then use &amp;0 to clear the part we don't need
  */
  return (x &gt;&gt; (n &lt;&lt; 3)) &amp; (0xFF);
}
/* 
 * logicalShift - shift x to the right by n, using a logical shift
 *   Can assume that 0 &lt;= n &lt;= 31
 *   Examples: logicalShift(0x87654321,4) = 0x08765432
 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 20
 *   Rating: 3 
 */
int logicalShift(int x, int n) {
  /*
   *All we need to do is to clear the sign bit after shifting
   *So we build a mask to make sure that the sign bit of (x&gt;&gt;n) is always 0
  */
  int mask = ~(((1 &lt;&lt; 31) &gt;&gt; n) &lt;&lt; 1); //set 1 for the hightest digit
  return mask &amp; (x &gt;&gt; n);
}
/*
 * bitCount - returns count of number of 1's in word
 *   Examples: bitCount(5) = 2, bitCount(7) = 3
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 40
 *   Rating: 4
 */
int bitCount(int x) {
  int mask1 = (0x55) | (0x55 &lt;&lt; 8) | (0x55 &lt;&lt; 16) | (0x55 &lt;&lt; 24); //  mask1=0x55555555
  int mask2 = (0x33) | (0x33 &lt;&lt; 8) | (0x33 &lt;&lt; 16) | (0x33 &lt;&lt; 24); //  mask2=0x33333333
  int mask3 = (0x0f) | (0x0f &lt;&lt; 8) | (0x0f &lt;&lt; 16) | (0x0f &lt;&lt; 24); //  mask3=0x0f0f0f0f
  int mask4 = (0xff) | (0xff &lt;&lt; 16);  //  mask4=0x00ff00ff
  int mask5 = (0xff) | (0xff &lt;&lt; 8);  // mask5=0x0000ffff
  int result; 
  /*
   *result = (mask1 &amp; x) + (mask1 &amp; (x &gt;&gt; 1));  //  add every 2 bits
   *result = (mask2 &amp; result) + (mask2 &amp; (result &gt;&gt; 2));  //  add every 4 bits
   *result = (mask3 &amp; result) + (mask3 &amp; (result &gt;&gt; 4));  //  add every 8 bits
   *result = (mask4 &amp; result) + (mask4 &amp; (result &gt;&gt; 8));  //  add every 16 bits
   *result = (mask5 &amp; result) + (mask5 &amp; (result &gt;&gt; 16)); //  add every 32 bits
  */
  result = (x &amp; mask1) + ((x &gt;&gt; 1) &amp; mask1);
  result = (result &amp; mask2) + ((result &gt;&gt; 2) &amp; mask2); 
  result = (result + (result &gt;&gt; 4)) &amp; mask3;
  result = (result + (result &gt;&gt; 8)) &amp; mask4;
  result = (result + (result &gt;&gt; 16)) &amp; mask5;
  return result;
}
/* 
 * bang - Compute !x without using !
 *   Examples: bang(3) = 0, bang(0) = 1
 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 4 
 */
int bang(int x) {
  return (~((x | (~x + 1)) &gt;&gt; 31) &amp; 1);
}
/* 
 * tmin - return minimum two's complement integer 
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 4
 *   Rating: 1
 */
int tmin(void) {
  return 1 &lt;&lt; 31;
}
/* 
 * fitsBits - return 1 if x can be represented as an 
 *  n-bit, two's complement integer.
 *   1 &lt;= n &lt;= 32
 *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 15
 *   Rating: 2
 */
int fitsBits(int x, int n) {
  /* if x can be represented as an n-bit, two's complement integer,
   * then high 32-n+1 bits are all 0s or 1s.
   */
  x = x &gt;&gt; (n + ~0);  /* x &gt;&gt; n-1, ~0 to get -1 */
  x = x + (x &amp; 1);
  return !x;
}
/* 
 * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30
 *  Round toward zero
 *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 15
 *   Rating: 2
 */
int divpwr2(int x, int n) {
    int sign = (x &gt;&gt; 31) &amp; 1; /* get sign */
    int mask = (1 &lt;&lt; n) + ~0;
    int lowbits = x &amp; mask;
    return (x &gt;&gt; n) + (((!lowbits) ^ 1) &amp; sign);
}
/* 
 * negate - return -x 
 *   Example: negate(1) = -1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 5
 *   Rating: 2
 */
int negate(int x) {
  return ~x + 1;
}
/* 
 * isPositive - return 1 if x &gt; 0, return 0 otherwise 
 *   Example: isPositive(-1) = 0.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 8
 *   Rating: 3
 */
int isPositive(int x) {
  return !((x &gt;&gt; 31) | !x);
}
/* 
 * isLessOrEqual - if x &lt;= y  then return 1, else return 0 
 *   Example: isLessOrEqual(4,5) = 1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 24
 *   Rating: 3
 */
int isLessOrEqual(int x, int y) {
  int z = (~x + 1) + y; /*  z = y - x  */
  int signx = (x &gt;&gt; 31) &amp; 1;
  int signy = (y &gt;&gt; 31) &amp; 1;
  int signz = (z &gt;&gt; 31) &amp; 1;
  /*  (x &lt; 0 and y &gt;= 0)  and  (x * y &gt;= 0 and x &lt;= y)  */
  return ((signx ^ signy) &amp; signx) + ((signx ^ signy ^ 1) &amp; !signz);
}
/*
 * ilog2 - return floor(log base 2 of x), where x &gt; 0
 *   Example: ilog2(16) = 4
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 90
 *   Rating: 4
 */
int ilog2(int x) {
  /*  while (x) x /= 2;
   *  use dichotomy to calculate the sum of 0s
   *  if there're x 0s on the left then shiftleft x bits
   */
  int x1, x2, x3, x4, x5, n;
  x1 = x &gt;&gt; 16;
  n = (16 &amp; ((!x1) &lt;&lt; 4));
  x = x &lt;&lt; (16 &amp; ((!x1) &lt;&lt; 4));
  x2 = x &gt;&gt; 24;
  n = n + (8 &amp; ((!x2) &lt;&lt; 3));
  x = x &lt;&lt; (8 &amp; ((!x2) &lt;&lt; 3));
  x3 = x &gt;&gt; 28;
  n = n + (4 &amp; ((!x3) &lt;&lt; 2));
  x = x &lt;&lt; (4 &amp; ((!x3) &lt;&lt; 2));
  x4 = x &gt;&gt; 30;
  n = n + (2 &amp; ((!x4) &lt;&lt; 1));
  x = x &lt;&lt; (2 &amp; ((!x4) &lt;&lt; 1));
  x5 = x &gt;&gt; 31;
  n = n + (1 &amp; (!x5));
  return 31 + ~n + 1;  /* 32 - (n + 1) */
}
/* 
 * float_neg - Return bit-level equivalent of expression -f for
 *   floating point argument f.
 *   Both the argument and result are passed as unsigned int's, but
 *   they are to be interpreted as the bit-level representations of
 *   single-precision floating point values.
 *   When argument is NaN, return argument.
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 10
 *   Rating: 2
 */
unsigned float_neg(unsigned uf) {
  unsigned result;  
  unsigned tmp;  
  tmp = uf &amp; 0x7fffffff;  /* remove sign bit */
  result = uf ^ 0x80000000; /* change sign bit */
  if ( tmp &gt; 0x7f800000)  /* NaN */
        result = uf;  
 return result;  
}
/* 
 * float_i2f - Return bit-level equivalent of expression (float) x
 *   Result is returned as unsigned int, but
 *   it is to be interpreted as the bit-level representation of a
 *   single-precision floating point values.
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned float_i2f(int x) {
  unsigned shiftLeft = 0, afterShift, tmp, flag, abs_x = x, sign = 0;  
  if (x == 0) 
    return 0; /* special case */
  /* get sign and abs for negative x */
  if (x &lt; 0)  
  {  
    sign = 0x80000000;  
    abs_x = -x;  
  }  
  afterShift = abs_x;  
  while (1)  
  {  
    tmp = afterShift;
    afterShift &lt;&lt;= 1;
    shiftLeft++;  /* count shiftleft */
    if (tmp &amp; 0x80000000)
      break;  
  }
  if ((afterShift &amp; 0x01ff) &gt; 0x0100)
    flag = 1;  
  else 
    if ((afterShift &amp; 0x03ff) == 0x0300)  
      flag = 1;  
    else
      flag = 0;
  /* construct the float expression */
  return sign + (afterShift &gt;&gt; 9) + ((159 - shiftLeft) &lt;&lt; 23) + flag;
}
/* 
 * float_twice - Return bit-level equivalent of expression 2*f for
 *   floating point argument f.
 *   Both the argument and result are passed as unsigned int's, but
 *   they are to be interpreted as the bit-level representation of
 *   single-precision floating point values.
 *   When argument is NaN, return argument
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned float_twice(unsigned uf) {
  unsigned f = uf;  
  /* Compute 2*f. If f is NaN, then return f */  
  if ((f &amp; 0x7F800000) == 0)
    f = ((f &amp; 0x007FFFFF) &lt;&lt; 1) | (0x80000000 &amp; f);
  else
    if ((f &amp; 0x7F800000) != 0x7F800000) /* exp can be extended */
      f =f+0x00800000;  /* exp + 1 */
  return f;  
}
/*
 * bitNor - ~(x|y) using only ~ and &amp;
 *   Example: bitNor(0x6, 0x5) = 0xFFFFFFF8
 *   Legal ops: ~ &amp;
 *   Max ops: 8
 *   Rating: 1
 */
int bitNor(int x, int y) {

  return (~x)&amp;(~y);
}
/*
 * bitXor - x^y using only ~ and &amp;
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &amp;
 *   Max ops: 14
 *   Rating: 2
 */
int bitXor(int x, int y) {
  int a=(~x)&amp;y;
  int b=x&amp;(~y);
  return ~(~a&amp;~b);
}
/*
 * leastBitPos - return a mask that marks the position of the
 *               least significant 1 bit. If x == 0, return 0
 *   Example: leastBitPos(96) = 0x20
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 6
 *   Rating: 4
 */
int leastBitPos(int x) {
    return x&amp;(~x+1);
}
/*
 * isNonNegative - return 1 if x &gt;= 0, return 0 otherwise
 *   Example: isNonNegative(-1) = 0.  isNonNegative(0) = 1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 6
 *   Rating: 3
 */
int isNonNegative(int x) {
    return !((x&gt;&gt;31)&amp;0x01);
}
/*
 * isGreater - if x &gt; y  then return 1, else return 0
 *   Example: isGreater(4,5) = 0, isGreater(5,4) = 1
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 24
 *   Rating: 3
 */
int isGreater(int x, int y) {
    int signofx=x&gt;&gt;31;
    int signofy=y&gt;&gt;31;
    int signequal=(!(signofx ^ signofy)) &amp; ((~y + x) &gt;&gt; 31);
    int signnequal=signofx &amp; !signofy;
    return !(signequal | signnequal);
}
/*
 * addOK - Determine if can compute x+y without overflow
 *   Example: addOK(0x80000000,0x80000000) = 0,
 *            addOK(0x80000000,0x70000000) = 1,
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 20
 *   Rating: 3
 */
int addOK(int x, int y) {
    int xysum = x + y;
    int signx = x &gt;&gt; 31;
    int signy = y &gt;&gt; 31;
    int signsumxy = xysum &gt;&gt; 31;  
    return !(~(signx ^ signy) &amp; (signx ^ signsumxy));
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode]Climbing Stairs]]></title>
    <link href="http://sumomoshinqi.github.io/blog/2015/03/20/leetcode-climbing-stairs/"/>
    <updated>2015-03-20T20:01:00+08:00</updated>
    <id>http://sumomoshinqi.github.io/blog/2015/03/20/leetcode-climbing-stairs</id>
    <content type="html"><![CDATA[<p>You are climbing a stair case. It takes n steps to reach to the top.</p>

<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>

<!--more-->


<pre><code class="C Climbing Stairs">int climbStairs(int n) {
    int stepOne = 1;
    int stepTwo = 0;
    int ret = 0;
    int i;

    for (i = 0; i &lt; n; i++) {
        ret = stepOne + stepTwo;
        stepTwo = stepOne;
        stepOne = ret;
    }

    return ret;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode]Majority Element]]></title>
    <link href="http://sumomoshinqi.github.io/blog/2015/03/20/leetcode-majority-element/"/>
    <updated>2015-03-20T19:57:22+08:00</updated>
    <id>http://sumomoshinqi.github.io/blog/2015/03/20/leetcode-majority-element</id>
    <content type="html"><![CDATA[<p>Given an array of size n, find the majority element. The majority element is the element that appears more than <em>⌊ n/2 ⌋</em> times.</p>

<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>

<!--more-->


<pre><code class="C Majority Element">intcomp(const void * a,const void * b)
{
    return * (int *)a - * (int *)b;
}
int majorityElement(int num[], int n) {
    qsort(num, n, sizeof(int), intcomp);
    return num[n/2];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[LeetCode]Compare Version Numbers]]></title>
    <link href="http://sumomoshinqi.github.io/blog/2015/03/20/leetcode-compare-version-numbers/"/>
    <updated>2015-03-20T19:27:39+08:00</updated>
    <id>http://sumomoshinqi.github.io/blog/2015/03/20/leetcode-compare-version-numbers</id>
    <content type="html"><![CDATA[<p>Compare two version numbers version1 and version2.  <br/>
If version1 > version2 return 1, if version1 &lt; version2 return -1, otherwise return 0.</p>

<p>You may assume that the version strings are non-empty and contain only digits and the . character.   <br/>
The <code>.</code> character does not represent a decimal point and is used to separate number sequences.  <br/>
For instance, <code>2.5</code> is not &ldquo;two and a half&rdquo; or &ldquo;half way to version three&rdquo;, it is the fifth second-level revision of the second first-level revision.</p>

<p>Here is an example of version numbers ordering: <br/>
<code>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37</code></p>

<!--more-->


<pre><code class="C compareVersion">int compareVersion(char * version1, char * version2){
    int v1 = 0, v2 = 0;
    int p1 = 0, p2 = 0;

    while (p1 &lt; strlen(version1) || p2 &lt; strlen(version2)) {
        v1 = 0;
        while (p1 &lt; strlen(version1)) {
            if (version1[p1] == '.') {
                ++p1;
                break;
            }
            v1 = 10 * v1 + (int)(version1[p1] - '0');
            ++p1;
        }

        v2 = 0;
        while (p2 &lt; strlen(version2)) {
            if (version2[p2] == '.') {
                ++p2;
                break;
            }
            v2 = 10 * v2 + (int)(version2[p2] - '0');
            ++p2;
        }

        if (v1 &lt; v2) {
            return -1;
        }
        else if (v1 &gt; v2) {
            return 1;
        }
    }

    return 0;
}  
</code></pre>
]]></content>
  </entry>
  
</feed>
